<?php

use Drupal\group\Entity\Group;
use Drupal\Core\Cache\Cache;
use GuzzleHttp\Client;
use Drupal\user\Entity\User;
use Drupal\user\UserInterface;
use GuzzleHttp\Exception\RequestException;
use Drupal\portland_openid_connect\Util\PortlandOpenIdConnectUtil;

/**
 * Implement hook_user_presave()
 * Keep the field_primary_groups value in sync with field_group_names
 */
function portland_openid_connect_user_presave($account)
{
  PortlandOpenIdConnectUtil::updatePrimaryGroupFieldForUser($account);
}

/**
 * Implement hook_user_create()
 */
function portland_openid_connect_user_insert($account)
{
  // Do nothing if it's a new user and is Contact Only
  if($account->field_is_contact_only->value == 1) return;
  PortlandOpenIdConnectUtil::updatePrimaryGroupMembershipForUser($account);
}

/**
 * Implement hook_user_update()
 * If a user is Contact Only, remove the user from all groups
 * If not, add the user to all her primary groups.
 */
function portland_openid_connect_user_update($account)
{
  // Remove "contact only" users from all groups
  if($account->field_is_contact_only->value == 1) {
    $current_primary_group_ids = PortlandOpenIdConnectUtil::getGroupIdsOfUser($account);
    foreach ($current_primary_group_ids as $current_primary_group_id) {
      $group = Group::load($current_primary_group_id);
      $group->removeMember($account);
      $group->save();
      Cache::invalidateTags($group->getCacheTagsToInvalidate());
    }
  }
  else {
    PortlandOpenIdConnectUtil::updatePrimaryGroupMembershipForUser($account);
  }
}

/**
 * Implement hook_cron()
 * 
 * When Cron got into a locked state, you will see the log "Attempting to re-run cron while it is already running.".
 * Run this command:
 *    drush sqlq "DELETE FROM semaphore WHERE name = 'cron';"
 * Get state values: 
 *    drush state:get pgov.user_sync.stop
 *    drush state:get pgov.user_sync.day_of_week
 *    drush state:get pgov.user_sync.interval_in_days
 *    drush state:get pgov.user_sync.batch_size
 *    drush state:get pgov.user_sync.last_date.DOMAIN
 *    drush state:get pgov.user_sync.resume_url.DOMAIN
 * To start sync from a fresh state:
 *    drush state:del pgov.user_sync.last_date.DOMAIN
 *    drush state:del pgov.user_sync.resume_url.DOMAIN
 */
function portland_openid_connect_cron()
{
  // To stop user sync: drush state:set pgov.user_sync.stop true
  // To restart user sync: drush state:delete pgov.user_sync.stop
  $stop_user_sync = \Drupal::state()->get('pgov.user_sync.stop');
  if (!empty($stop_user_sync) && strtolower($stop_user_sync) === "true") {
    \Drupal::logger('portland OpenID')->notice("pgov.user_sync.stop set to TRUE. Skip user sync.");
    return;
  }

  // Get the day of the week to sync. Default is Saturday.
  $sync_day = \Drupal::state()->get('pgov.user_sync.day_of_week') ?? "Saturday";
  if(date("l") != $sync_day) return;

  // Get the sync interval in days. Default is 7 days.
  $sync_interval = \Drupal::state()->get('pgov.user_sync.interval_in_days') ?? "7";

  // Domains should be defined as constants in PortlandOpenIdConnectUtil
  $domains = [
    PortlandOpenIdConnectUtil::ROSE_DOMAIN_NAME,
    PortlandOpenIdConnectUtil::PTLD_DOMAIN_NAME,
  ];
  foreach($domains as $domain) {
    // Get the last sync date. Default to 8 days ago.
    $last_user_sync_date = \Drupal::state()->get("pgov.user_sync.last_date.$domain");
    $last_user_sync_date = empty($last_user_sync_date) ? (new DateTime("2024-10-01")) : new DateTime($last_user_sync_date);

    // Do nothing if the last sync was done within the interval
    $now = new DateTime();
    if($now->diff($last_user_sync_date)->days < (int)$sync_interval) break;

    $tokens = PortlandOpenIdConnectUtil::GetAccessToken($domain);
    if (empty($tokens) || empty($tokens['access_token'])) {
      \Drupal::logger('portland OpenID')->error("Cannot retrieve access token for Microsoft Graph for domain $domain. Make sure the client credentials are correct and not expired.");
      return;
    }
    _get_all_users($tokens['access_token'], $domain);
  }
}

/**
 * Call the user delta API to get users incrementally
 */
function _get_all_users($access_token, $domain = PortlandOpenIdConnectUtil::ROSE_DOMAIN_NAME)
{
  $system_state = \Drupal::state();

  /* @var \GuzzleHttp\ClientInterface $client */
  $client = new Client();
  // Perform the request.
  $options = [
    'method' => 'GET',
    'headers' => [
      'Content-Type' => 'application/json',
      'Authorization' => 'Bearer ' . $access_token,
      'ConsistencyLevel' => 'eventual',
    ]
  ];

  try {
    // Run this command to delete the resume link in order to start fresh
    // lando drush state:del pgov.user_sync.resume_url.DOMAIN

    if ($resume_url = $system_state->get("pgov.user_sync.resume_url.$domain")) {
      \Drupal::logger('portland OpenID')->notice("Resume user sync for $domain ...");
    } else {
      \Drupal::logger('portland OpenID')->notice("Start user sync for $domain ...");
    }

    // Get the user sync batch size. Default is 100 users
    $batch_size = \Drupal::state()->get('pgov.user_sync.batch_size') ?? "100";

    // If there is a resume link, use it. Otherwise start fresh
    // The hardcoded initial URL is intentional. It's only used for the first request.
    $request_url = $resume_url ?? "https://graph.microsoft.com/v1.0/users?\$top=$batch_size&\$filter=endswith(mail,'@$domain')&\$orderby=userPrincipalName&\$count=true&\$select=id,accountEnabled,userPrincipalName,displayName,givenName,surname,jobTitle,mail,companyName,department,officeLocation,businessPhones,mobilePhone,employeeId,userType,employeeType,streetAddress,city,state,postalCode,mailNickname";
    // Queue up 10 items in each call
    $request_limit = 10;
    $request_count = 0;
    $response_data = null;
    while (strlen($request_url) > 0 && $request_count < $request_limit) {
      $response = $client->get($request_url, $options);
      $response_data = json_decode((string) $response->getBody(), TRUE);
      
      /** @var QueueFactory $queue_factory */
      $queue_factory = \Drupal::service('queue');
      /** @var QueueInterface $queue */
      $queue = $queue_factory->get('user_sync');
      $queue->createItem([
        "access_token" => $access_token,
        "domain" => $domain,
        "users" => $response_data['value']
      ]);

      if( isset($response_data['@odata.nextLink']) ) {
        $request_url = $response_data['@odata.nextLink'] ?? '';
        $request_count++;
      }
      else {
        break;
      }
    }

    // When there is @odata.nextLink, prepare for the next run
    if( isset($response_data['@odata.nextLink']) ) {
      $system_state->set("pgov.user_sync.resume_url.$domain", $response_data['@odata.nextLink']);
      \Drupal::logger('portland OpenID')->info("@odata.nextLink updated for domain $domain.");
    }
    // When there is no @odata.nextLink, there is no more user to sync
    else {
      \Drupal::state()->set("pgov.user_sync.last_date.$domain", (new DateTime())->format('Y-m-d'));
      $system_state->set("pgov.user_sync.resume_url.$domain", '');
      \Drupal::logger('portland OpenID')->info("All users have been sychronized in domain $domain.");
    }
  } catch (RequestException $e) {
    $variables = [
      '@message' => 'Cannot synchronize users from ' . $domain,
      '@error_message' => $e->getMessage(),
    ];
    \Drupal::logger('portland OpenID')->error('@message. Details: @error_message', $variables);
  }
}
